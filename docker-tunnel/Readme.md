# داکر-تونل

این یک جایگزین مبتنی بر Docker و میزبانی خود برای Ngrok است. این برنامه یک برنامه وب را که به صورت محلی روی یک ماشین توسعه اجرا می‌شود، با استفاده از یک تونل معکوس امن SSH به سروری که قبلاً در معرض اینترنت است، در معرض اینترنت قرار می‌دهد. از این پست وبلاگ الهام گرفته شده است. همچنین پست وبلاگ من را ببینید که توضیح می دهد چگونه کد کار می کند.

# موارد استفاده نمونه

آزمایش برنامه ای که به صورت محلی در حال اجرا است از اینترنت - بدون نیاز به استقرار برنامه در برخی از سرورها. این می تواند برای بازخورد سریعتر به عنوان مثال از مشتریان در طول توسعه مفید باشد.
اجازه می دهد چالش HTTP را برای تأیید دامنه رمزگذاری کنیم تا با برنامه هایی کار کند که در غیر این صورت مستقیماً در معرض اینترنت نیستند. به عنوان مثال، من برای آزمایش یک برنامه SaaS که روی یک خوشه محلی Kubernetes اجرا می شود، به این نیاز داشتم، که به کاربران امکان می دهد دامنه های سفارشی خارج از کنترل من را اضافه کنند که نمی توانم از روش تأیید DNS برای آنها استفاده کنم.
استفاده
با یک مثال ساده تر است. فرض کنید می‌خواهید برنامه شما درخواست‌های HTTP از اینترنت را روی پورت‌های معمولی 80 و 443 بپذیرد، و برنامه همچنین به پورت‌های 80 و 443 روی دستگاه توسعه‌دهنده شما گوش می‌دهد، بنابراین می‌توانید برنامه را با HTTP و هر دو تست کنید. درخواست های HTTPS مانند زمان تولید. برای راه‌اندازی تونل و نمایش برنامه‌تان، دو کانتینر لازم است. ابتدا روی سروری که در معرض اینترنت قرار دارد و داکر نصب شده است (سرور پروکسی) اجرا کنید:
```
docker run --name tunnel-proxy --env PORTS="80:3000,443:3001" -itd --net=host opiran-club/tunnel:0.31.0 proxy
```
هر مقدار در متغیر محیطی PORTS یک نقشه بین یک پورت در معرض اینترنت (بگذارید آن را پورت A بنامیم) و یک پورت مربوطه (B) است که توسط تونل SSH - که توسط ماشین توسعه دهنده شما آغاز شده است - برای ارسال درخواست های انجام شده استفاده می شود. به پورت A به برنامه روی دستگاه توسعه دهنده شما. پورت دوم باید با هر یک از پورت های در معرض اینترنت متفاوت باشد زیرا Nginx به آن پورت ها گوش می دهد.

سپس، در دستگاه توسعه دهنده خود، اجرا کنید:
```
docker run --name tunnel-app --env PORTS="80:3000,443:3001" --env PROXY_HOST="1.2.3.4" --env PROXY_SSH_PORT="22" --env PROXY_SSH_USER="${USER} " -v "${HOME}/.ssh/id_rsa:/ssh.key" -itd opiran-club/tunnel:0.31.0 app
```
یک آرگومان اختیاری APP_IP وجود دارد که به صورت پیش‌فرض روی IP میزبان Docker است، اما اگر درخواست‌ها باید به یک IP خاص ارسال شوند، می‌توان آن را پیکربندی کرد.

در اینجا هر زوج در PORTS یک نقشه بین پورتی است که برنامه در دستگاه توسعه دهنده شما (C) به آن گوش می دهد، و پورتی که در سرور پراکسی توسط اتصال SSH برای ارسال درخواست ها به برنامه استفاده می شود، بنابراین در این ثانیه پورت باید با پورت B مشخص شده برای سرور پراکسی مطابقت داشته باشد. بنابراین شما اساسا یک تونل C->B->A دارید، به عنوان مثال از پورت 80 برنامه خود، تا پورت 80 که در اینترنت از طریق یک تونل SSH با استفاده از پورت 3000 در معرض دید قرار گرفته است. امیدوارم منطقی باشد :)

توجه داشته باشید که فرض بر این است که اتصال SSH از احراز هویت کلید استفاده می کند، بنابراین باید کلید SSH را که می خواهید استفاده کنید، همانطور که در دستور بالا نشان داده شده است سوار کنید.
